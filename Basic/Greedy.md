# 第五章、貪心演算法

---

## 貪心的概念

貪心演算法（Greedy Algorithm）是一種解決問題的方法，它的核心思想是在每一個決策點都選擇當下看起來最好的選擇，而不考慮這個選擇對未來可能產生的影響。

透過這種逐步的局部最優選擇，希望最終能得到整體的最佳解。

貪心演算法通常適用於那些具有「貪心選擇性質」和「最優子結構」的問題

也就是說，局部最優的選擇能導致全局最優的結果。

這種方法的優點是思路簡單、運算快速，但並非所有問題都適用，因為有些情況下局部最優並不等於全局最優。

最簡單的例子就是國小數學題，用 $1,2,3,4,5$ 組成一個最大的五位數，每個數字只能用一次

很直觀的我們會把月大的數放在越左邊，這就是 **貪心** 的實現

經常遇到的問題可以分成 **貪心選擇性質** 和 **最優子結構** 兩種

---

## 排程問題

> ### [APCS - 機器出租](https://zerojudge.tw/ShowProblem?problemid=j608)
>
> 難度： $3/10$

題目大概的敘述就是說有 $n$ 個活動和 $k$ 台機器，每個活動有開始時間和結束時間 $[L_i,R_i]$

一台機器同時間只能借給一個活動，問最多可以成功舉辦多少場活動？

先討論 $K=1$ 的情況

有 $1$ 台機器和 $n$ 個活動，求最多能辦幾場活動

最直觀的想法來說，有以下幾種：

- 選活動持續時間最短的先辦 ($R_i-L_i$)
- 選開始時間比較早的先辦 ($L_i$)
- 選結束時間比較晚的先辦 ($R_i$)

其實答案應該是選結束時間比較晚的先辦 ($R_i$)

畢竟這樣選不會吃虧，越早結束就能考慮更多活動

不管開始的時間為何，只要越早結束對我們越有利

所以我們只要對所有活動的結束時間 $R$ 排序後逐一檢查不重疊的情況下可以辦幾場就好

```cpp
#define l first
#define r second
using itv = pair<int,int>;
int n,k;
cin >> n >> k;
vector<itv> ti(n);
for(int i=0;i<n;i++) cin >> ti[i].l;
for(int i=0;i<n;i++) cin >> ti[i].r;
sort(ti.begin(), ti.end(), [&](const itv &a, const itv &b) {
    return a.r < b.r;
});
int ans = 1, cur_R = ti[0].r;
for(int i=1;i<n;i++) {
    // 如果時間沒有重疊
    if(ti[i].l > cur_R) {
        cur_R = ti[i].r;
        ans ++;
    }
}
return cout << ans,0;
```

那麼如果有 $K$ 台機器的情況呢？

很顯然貪心的策略仍然成立，只不過可以同時辦很多個活動而已

要如何同時處理呢？假設 $K=2$ 目前已經辦的活動是 $[1,2]$ , $[1,3]$

現在要辦一場 $[4,10]$ 的活動，應該接在哪台機器後面呢？

顯然是 $[1,3]$ 那台，畢竟我們可以把彈性更多的那台（結束時間是 $2$）留給後面可能出現的區間

舉例來說如果又有一個活動時間為 $[3,12]$

如果你把 $[4,10]$ 接在 $[1,2]$ 後面，你就不能辦理 $[3,12]$，答案為 $3$

但是如果把 $[4,10]$ 接在 $[1,3]$ 後面，你可以辦理 $[3,12]$，答案為 $4$

因此我們的目標就是找的不回重疊的活動中結束時間最晚的接在後面

如何達成這個操作呢？使用 `multiset` 維護即可

```cpp
multiset<int> used;
int ans = 0;
for(int i=0;i<k;i++) used.insert(0);
for(int i=0;i<n;i++) {
    auto found = used.lower_bound(ti[i].l);
    if(found != used.begin()) {
        ans++;
        used.erase(prev(found));
        used.insert(ti[i].r);
    }
}
return cout << ans,0;
```

---

## 偏序問題

> ### [校內模擬賽 - 增幅魔法 Explosion](https://codeforces.com/gym/634550/problem/B)
>
> 難度： $3.5/10$

在這類問題中，我們有多個一次函數 $F_i(x)=a_i\cdot x+b_i$​

需要決定它們的應用順序，依次套用到初始值 $x_0$

由於線性函數的組合會受到順序影響，不同的排列方式可能產生不同的最終結果。

因此這類問題的解題的核心就是如何決定這些一次函數的最佳排列，使最後的結果最大化。

也就是說它存在一個貪心策略可以將這個套用函數的順序排序

我們可以假設我們要比較相鄰的第 $i$ 項與第 $j$ 項誰要先被套用（並假設前 $i-1$ 項已經是最優解，其值為 $K$）

不失一般性假設 $i$ 要先於 $j$，也就是說 $F_j(F_i(K)) > F_i(F_j(K))$

因此可以列出不等式

$$a_j(a_iK+b_i)+b_j > a_i(a_jK+b_j)+b_i$$

$$a_ia_jK + a_jb_i+b_j > a_ia_jK+a_ib_j+b_i$$

$$a_jb_i+b_j > a_ib_j+b_i$$

$$b_i(a_j - 1) > b_j(a_i - 1)$$

$$\frac{b_i}{a_i-1} > \frac{b_j}{a_j-1}$$

我們只需要用這個條件去 `sort` 就可以得到最優解

不過要注意的是我們要避免使用浮點數去比較大小以免出現 `rounding error`

因此我們要交叉相乘，寫成乘法的形式去比較

小提醒：題目有要求對 $10^9+7$ 取模

```cpp
int n,x;
cin >> n >> x;
vector<pair<int,int>> f(n);
for(auto &[a,b] : f) cin >> a >> b;
sort(f.begin(),f.end(),[&](pair<int,int> &a,pair<int,int> &b) {
    return a.second * (b.first-1) > b.second * (a.first-1);
});
for(int i=0;i<n;i++) {
    x = (f[i].first * x % mod + f[i].second % mod) % mod;
}
return cout<<x%mod,0;
```
