# 第五章、貪心演算法

---

## 貪心的概念

貪心演算法（Greedy Algorithm）是一種解決問題的方法，它的核心思想是在每一個決策點都選擇當下看起來最好的選擇，而不考慮這個選擇對未來可能產生的影響。

透過這種逐步的局部最優選擇，希望最終能得到整體的最佳解。

貪心演算法通常適用於那些具有「貪心選擇性質」和「最優子結構」的問題

也就是說，局部最優的選擇能導致全局最優的結果。

這種方法的優點是思路簡單、運算快速，但並非所有問題都適用，因為有些情況下局部最優並不等於全局最優。

最簡單的例子就是國小數學題，用 $1,2,3,4,5$ 組成一個最大的五位數，每個數字只能用一次

很直觀的我們會把月大的數放在越左邊，這就是 **貪心** 的實現

經常遇到的問題可以分成 **貪心選擇性質** 和 **最優子結構** 兩種

---

## 排程問題

> ### [APCS - 機器出租](https://zerojudge.tw/ShowProblem?problemid=j608)
>
> 難度： $3/10$

題目大概的敘述就是說有 $n$ 個活動和 $k$ 台機器，每個活動有開始時間和結束時間 $(L_i,R_i)$

一台機器同時間只能借給一個活動，問最多可以成功舉辦多少場活動？

先討論 $K=1$ 的情況

有 $1$ 台機器和 $n$ 個活動，求最多能辦幾場活動

最直觀的想法來說，有以下幾種：

- 選活動持續時間最短的先辦 ($R_i-L_i$)
- 選開始時間比較早的先辦 ($L_i$)
- 選結束時間比較晚的先辦 ($R_i$)

其實答案應該是選結束時間比較晚的先辦 ($R_i$)

畢竟這樣選不會吃虧，越早結束就能考慮更多活動

不管開始的時間為何，只要越早結束對我們越有利

所以我們只要對所有活動的結束時間 $R$ 排序後逐一檢查不重疊的情況下可以辦幾場就好

```cpp
#define l first
#define r second
using itv = pair<int,int>;
int n,k;
cin >> n >> k;
vector<itv> ti(n);
for(int i=0;i<n;i++) cin >> ti[i].l;
for(int i=0;i<n;i++) cin >> ti[i].r;
sort(ti.begin(), ti.end(), [&](const itv &a, const itv &b) {
    return a.r < b.r;
});
int ans = 1, cur_R = ti[0].r;
for(int i=1;i<n;i++) {
    // 如果時間沒有重疊
    if(ti[i].l > cur_R) {
        cur_R = ti[i].r;
        ans ++;
    }
}
return cout << ans,0;
```

