# 第二章、暴力枚舉

---

## 簡介

**枚舉** (Enumerate)，顧名思義，也叫做窮舉，即考慮所有可能的答案去取需要的結果

舉例來說：
假設你今天要決定出門要不要帶：
- 雨傘
- 外套

每個東西都有「要帶」或「不帶」兩種選擇。  
- 如果只有雨傘 $\rightarrow 2$ 種情況  
- 如果有雨傘 + 外套 $\rightarrow 2 × 2 = 4$ 種情況  
- 如果還有帽子 $\rightarrow 2 × 2 × 2 = 8$ 種情況  

這就是窮舉：**全部列出來**

---

## 迴圈枚舉

利用 `for` 迴圈枚舉所有可能情況，是 **比賽中經常會出現的子題模式**，我們只需要考慮所有子樣本空間即可求出最後答案

> 複雜度 $O(n^k)$ $(k$ 層迴圈 $)$

先看個簡單的例題

> ### [Atcoder ABC389 B - tcaF](https://atcoder.jp/contests/abc389/tasks/abc389_b)
>
> 題目大意：給定一個值 $X$，求 $N$ 滿足 $N! = X$
>
> 限制：$2\leq X\leq 3\times 10^{18}$

很顯然，我們只要窮舉 $[1,20]$ 中所有可能直接比對就能知道答案

不過這題太簡單大家都會

> ### [Atcoder ABC393 B - A..B..C](https://atcoder.jp/contests/abc393/tasks/abc393_b)
>
> 題目大意：給定字串 $S$，問有幾個點對 $(i,j,k)$ 滿足 $i<j<k$ ， $2j = k + i$，並且 $(S_i,S_j,S_k) = (A,B,C)$
>
> 限制：$3\leq |S|\leq 100$

因為 $S$ 的長度很小，因此直接枚舉所有可能即可

不過注意到因為 $2j = k + i$，因此我們只需要枚舉 $i,j$ 兩個可能， $k$ 就會順便被決定好

```cpp
int ans = 0;
for(int i=0;i<s.size();i++) {
    for(int j=i+1;j<s.size();j++) {
        int k = 2 * j - i;
        if(s[i] == 'A' && s[j] == 'B' && s[k] == 'C') {
            ans += 1;
        }
    }
}
```

這樣複雜度 $O(|S|^2)$

---

## Bitmask 枚舉子集

Bitmask 可以想像是一個 **用 0 和 1 表示選擇的密碼**。

- `0` 代表「不選」
- `1` 代表「選」

舉例：
還是雨傘 + 外套 + 帽子：
- `000` → 三個都不帶
- `001` → 只帶帽子
- `010` → 只帶外套
- `011` → 帶外套和帽子
- `100` → 只帶雨傘
- `101` → 帶雨傘和帽子
- `110` → 帶雨傘和外套
- `111` → 三個都帶

總共 8 種情況，剛好對應二進位的數字 `0 ~ 7`。

如果我們用「巢狀 for 迴圈」去列舉會很麻煩：

```cpp
for (雨傘的選擇) {
    for (外套的選擇) {
        for (帽子的選擇) {
            // 做事情
        }
    }
}
```

一旦物品很多，巢狀迴圈就會變得超長。
但是用 bitmask，我們只需要一個迴圈：

```cpp
for (int mask = 0; mask < (1 << n); mask++) {
    // 用 mask 來表示一種選擇
}
```

這樣就能列出 所有 $2^n$ 種可能。

### 實作概念

> 先確保自己已經熟練位元運算 `&`,`|`,`^`,`>>`,`<<`...

如何判斷某個東西有沒有被選？

假設我們有一個數字 $mask$，它的第 $i$ 個 bit 表示第 $i$ 個東西有沒有被選。

要檢查第 $i$ 個東西就是利用 `&` 運算判斷是否為 $1$

```cpp
if (mask & (1 << i)) {
    // 也可以寫成 (mask >> i) & 1
    // 第 i 個東西有被選
} else {
    // 第 i 個東西沒有被選
}
```

### 範例程式

> 假設有一個長度為 $n$ 的序列 $A_n$，則以下程式為列舉其所有可能選擇方法的寫法

```cpp
vector<int> A(n);
for(int status = 0; status < (1<<n); status++) {
    for(int i = 0; i < n; i++) {
        if((status >> i) & 1) {
            // 1的情況，即有選擇
        }
        else {
            // 0 的情況，即不選擇
        }
    }
}
```

---
## 練習

> ### [Bocchi's Setlist](https://codeforces.com/gym/634550/problem/A))
>
> 題目位於 [Codeforces 上的題單](https://codeforces.com/contestInvitation/e60938670c2d65c4bb70f162d34e0f640dc900e8)中
